"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UploadError = void 0;

var _fs = _interopRequireDefault(require("mz/fs"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _formData = _interopRequireDefault(require("form-data"));

var _isDirectory = _interopRequireDefault(require("./isDirectory"));

var _isReadable = _interopRequireDefault(require("./isReadable"));

var _readScreenshots = _interopRequireWildcard(require("./readScreenshots"));

var _getEnvironment = require("./getEnvironment");

var _config = _interopRequireDefault(require("./config"));

var _display = require("./display");

var _package = _interopRequireDefault(require("../package.json"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class UploadError extends Error {}

exports.UploadError = UploadError;

async function upload(options) {
  const {
    directory,
    ignore = [],
    token: tokenOption,
    branch: branchOption,
    commit: commitOption,
    externalBuildId: externalBuildIdOption,
    buildName: buildNameOption,
    batchCount: batchCountOption
  } = options;

  const token = tokenOption || _config.default.get("token");

  const definedCommit = commitOption || _config.default.get("commit");

  const ciContext = process.env.ARGOS_CLI_TEST !== "true" && !definedCommit ? (0, _getEnvironment.getEnvironment)({
    env: process.env
  }) : null;
  const commit = definedCommit || (ciContext === null || ciContext === void 0 ? void 0 : ciContext.commit) || null;
  const branch = branchOption || _config.default.get("branch") || (ciContext === null || ciContext === void 0 ? void 0 : ciContext.branch) || null;

  const externalBuildId = externalBuildIdOption || _config.default.get("externalBuildId");

  const batchCount = batchCountOption || _config.default.get("batchCount");

  const name = buildNameOption || _config.default.get("buildName");

  if (ciContext) {
    (0, _display.displayInfo)(`"${ciContext.name}" CI detected.`);
  }

  if (!token) {
    throw new UploadError("Token missing: use ARGOS_TOKEN or the --token option.");
  }

  if (!branch) {
    throw new UploadError("Branch missing: use ARGOS_BRANCH or the --branch option.");
  }

  if (!commit) {
    throw new UploadError("Commit missing: use ARGOS_COMMIT or the --commit option.");
  }

  if (!(await (0, _isDirectory.default)(directory))) {
    throw new UploadError("The path provided is not a directory.");
  }

  if (!(await (0, _isReadable.default)(directory))) {
    throw new UploadError("The path provided is not a readable, please check fs rights.");
  }

  (0, _display.displayInfo)(`using \`${branch}\` as branch`);
  (0, _display.displayInfo)(`using \`${commit}\` as commit`);
  const screenshots = await (0, _readScreenshots.default)({
    cwd: directory,
    ignore
  });

  if (screenshots.length === 0 && !externalBuildId) {
    throw new UploadError(`The path provided doesn't contain any image (${_readScreenshots.GLOB_PATTERN}).`);
  }

  (0, _display.displayInfo)(`found ${screenshots.length} screenshots to upload`);
  const body = new _formData.default();
  body.append("data", JSON.stringify({
    name,
    branch,
    commit,
    token,
    externalBuildId,
    batchCount,
    names: screenshots.map(screenshot => screenshot.name)
  }));
  screenshots.reduce((body, screenshot) => {
    body.append("screenshots[]", _fs.default.createReadStream(screenshot.filename));
    return body;
  }, body);
  return (0, _nodeFetch.default)(`${_config.default.get("endpoint")}/builds`, {
    headers: {
      "X-Argos-CLI-Version": _package.default.version
    },
    method: "POST",
    body
  });
}

var _default = upload;
exports.default = _default;